//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////	As a patch or action, take a list of variables, return the first entry, and strip it from the list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION "RETURN_FIRST_ENTRY"
STR_VAR
	"list" = ""
	"separator" = " "
RET
	"entry"
	"remaining_list"
BEGIN
	OUTER_SET "x" = INDEX (CASE_INSENSITIVE EXACT_MATCH "%separator%" "%list%")
	ACTION_IF ("%x%" == "-1") BEGIN
		// If it can't find "%separator%", then this is the last entry => Find end of string
		OUTER_SET "x" = INDEX (CASE_INSENSITIVE EVALUATE_REGEXP "$" "%list%")
		OUTER_TEXT_SPRINT "remaining_list" ""
	END
	OUTER_SET "y" = STRING_LENGTH "%list%"

	LAF "SUBSTRING"
	INT_VAR
		"length" = "%x%"
	STR_VAR
		"string" = "%list%"
	RET
		"entry" = "substring"
	END

	ACTION_IF ("%remaining_list%" STRING_COMPARE_CASE "") BEGIN
		LAF "SUBSTRING"
		INT_VAR
			"start" = "%x%" + STRING_LENGTH "%separator%"	// We need to take into account the length of "%separator%"
			"length" = "%y%" - ("%x%" + STRING_LENGTH "%separator%")	// We need to take into account the length of "%separator%"
		STR_VAR
			"string" = "%list%"
		RET
			"remaining_list" = "substring"
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	As a patch or action, take a list of space-separated key => value pairs, return the first entries, and strip them from the list
//	Moreover, it checks if the pair ~key=>value~ is legal (namely, ~%key%~ and ~%value%~ cannot contain "=>" characters)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION "RETURN_KEY_VALUE"
STR_VAR
	"list" = ""
RET
	"key"
	"value"
BEGIN
	ACTION_IF (("%list%" STRING_MATCHES_REGEXP "^[^ %NL%%TAB%]+=>[^%NL%%TAB%]+$") == 0) BEGIN
		LAF "CHECK_PAIR"
		STR_VAR
			"pair" = "%list%"
		END
		OUTER_PATCH "%list%" BEGIN
			REPLACE_EVALUATE CASE_INSENSITIVE "\(^[^ %NL%%TAB%]+\)=>\([^%NL%%TAB%]+$\)" BEGIN
				TEXT_SPRINT "key" "%MATCH1%"
				TEXT_SPRINT "value" "%MATCH2%"
			END
			""
		END
		// Quick sanity check
		ACTION_IF (("%value%" STRING_CONTAINS_REGEXP "^[ %NL%%TAB%]+") == 0) OR (("%value%" STRING_CONTAINS_REGEXP "[ %NL%%TAB%]+$") == 0) BEGIN
			FAIL "~%DEST_FILE%~, RETURN_KEY_VALUE: string ~%list%~ appears to be malformed. Please stick to the following template: ~key=>value~"
		END
	END ELSE BEGIN
		FAIL "~%DEST_FILE%~, RETURN_KEY_VALUE: string ~%list%~ appears to be malformed. Please stick to the following template: ~key=>value~"
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////	Return the number of items in a list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION "LENGTH_OF_LIST"
STR_VAR
	"list" = ""
	"separator" = " "
RET
	"length"
BEGIN
	// Init
	OUTER_SET "length" = 0
	// Main
	OUTER_WHILE ("%list%" STRING_COMPARE_CASE "") BEGIN
		LAF "RETURN_FIRST_ENTRY"
		STR_VAR
			"list"
			"separator"
		RET
			"list" = "remaining_list"
		END
		OUTER_SET "length" += 1
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	[REGEXP] WeiDU doesn't support "negative lookahead" and the like,
//	so in order to avoid writing a too complex regexp, we'll manipulate input string (REPLACE_TEXTUALLY) beforehand
//
//	We're looking for illegal characters like "=>". For instance: header=>type=>1
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION "CHECK_PAIR"
STR_VAR
	"pair" = ""	// header=>type=>1
BEGIN
	OUTER_PATCH "%pair%" BEGIN
		COUNT_REGEXP_INSTANCES CASE_INSENSITIVE EXACT_MATCH "=>" "x"
	END
	ACTION_IF ("%x%" != 1) BEGIN
		FAIL "~%DEST_FILE%~, CHECK_PAIR: string ~%pair%~ cannot contain multiple ~=>~ characters"
	END
END